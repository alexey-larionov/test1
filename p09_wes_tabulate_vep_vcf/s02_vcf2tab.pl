#!/usr/bin/perl

# s02_vcf2tab.pl
# Convert vcf-vep to tab-delimited text files
# Alexey Larionov, 27Oct2015

# Use: s02_vcf2tab.pl dataset_name input_vcf output_folder
# e.g.:

# s02_vcf2tab.pl \
#   wecare_oct2015_vqsr_qual100_vep \
#   /scratch/medgen/users/alexey/wecare/tabulated_vep_vcf/source_files/wecare_oct2015_vqsr_qual100_vep.vcf \
#   /scratch/medgen/users/alexey/wecare/tabulated_vep_vcf

# Notes

# Input file and output folder should exist

# Script is intended only for files generated by GATK and annotated by VEP

# GATK VQSR adds to INFO some records that are not in format ID=VALUE e.g. POSITIVE_TRAIN_SITE; 
# (something similar may be done by samtools about INDELS ...)

# Importantly, description of such VQSR insertions may be missed in the file header.
# To preserve all such inclusions, which are not described in the header, 
# one might need to read the file twice: first - to analyse INFO field, second - to parce it.

# This script ignores any inclusions not described in the header and only interprets 
# info values in format ID=VALUE.  

# Set environment
use strict;
use warnings;

# -------------------------------------------------------- #
#                     Initial settings                     #
# -------------------------------------------------------- #

my $dataset = $ARGV[0];
my $vcf_in = $ARGV[1];
my $folder_out = $ARGV[2];

my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime();
print	"Tabulating VCF VEP file\n".
      "Started: $hour:$min:$sec\n\n".
		  "Dataset: $dataset\n".
		  "Input VCF file: $vcf_in\n".
		  "Output folder: $folder_out\n\n";

# -------------------------------------------------------- #
#                     Read vcf header                      #
# -------------------------------------------------------- #

my $vcf_in_fh;
my $header_line;
my @info_fields;
my @header_formats;
my @vep_fields;

# Open input file
open $vcf_in_fh, "<$vcf_in" or die "\nInput file $vcf_in cannot be opened: $!\n\n";

# Read lines until the one starting with #CHROM
while (<$vcf_in_fh>) {
  
  # info field names
  if (/^##INFO/) {
    m/<(.+)>/;
    $1 =~ /ID=(.+?),/;
    push(@info_fields, $1);
  }

  # format field names
  if (/^##FORMAT/) {
    m/<(.+)>/;
    $1 =~ /ID=(.+?),/;
    push(@header_formats, $1);
  }
  
  # vep field names
  if (/^##INFO=<ID=CSQ,/) {
    m/<.+?Format: (.+)\">/;
    @vep_fields = split(/\|/, $1);
  }

  # header line (contains vcf fields and samples)
  if (/^#CHROM/) {
    chomp;
    $header_line = $_;
    last; # exit while, assuming that this is the last line of header
  }
}

# ----- Parce header line ----- #

# Spli line to array
my @header_line = split("\t", $header_line);

# used later for file format check
my $fields_num = scalar @header_line; 

# Check and get standard vcf file names
my @vcf_fields;
if ( $header_line[0] eq "#CHROM" && 
     $header_line[1] eq "POS" && 
     $header_line[2] eq "ID" && 
     $header_line[3] eq "REF" && 
     $header_line[4] eq "ALT" &&
     $header_line[5] eq "QUAL" && 
     $header_line[6] eq "FILTER" && 
     $header_line[7] eq "INFO" &&  
     $header_line[8] eq "FORMAT" ) {
     
  @vcf_fields = @header_line[0..6];
  $vcf_fields[0] = "CHROM";
  
} else {
  print "\nUnexpected file format\n\n";
  exit 1;
}

# Get samples names
my @samples = @header_line[9..$#header_line];

# ----- Progress report ---- #

my $info_fields_num = scalar @info_fields;
my $formats_num = scalar @header_formats;
my $samples_num = scalar @samples;

print	"Detected all standard vcf fields\n".
		  "$info_fields_num info fields\n".
		  "$formats_num formats\n".
		  "$samples_num samples\n\n";

# -------------------------------------------------------- #
#                     Prepare output files                 #
# -------------------------------------------------------- #

# ----- vcf ----- #

my $vcf_out_fh;
my $vcf_out = "$folder_out/${dataset}_vcf_std.txt";
open $vcf_out_fh, ">$vcf_out" or die "\nOutput file $vcf_out cannot be created: $!\n\n";

unshift @vcf_fields, 'variant_ID';
print $vcf_out_fh join("\t", @vcf_fields)."\n";

# ----- info ----- #

my $info_out_fh;
my $info_out = "$folder_out/${dataset}_vcf_info.txt";
open $info_out_fh, ">$info_out" or die "\nOutput file $info_out cannot be created: $!\n\n";

unshift @info_fields, 'variant_ID';

my $last_info_field = pop @info_fields; # remove "CSQ" (the last info field with vep annotation)
print $info_out_fh join("\t", @info_fields)."\n";
push @info_fields, $last_info_field; # return "CSQ"

# ----- vep ----- #

my $vep_out_fh;
my $vep_out = "$folder_out/${dataset}_vep.txt";
open $vep_out_fh, ">$vep_out" or die "\nOutput file $vep_out cannot be created: $!\n\n";

unshift @vep_fields, 'variant_ID';
print $vep_out_fh join("\t", @vep_fields)."\n";

# ---- formats ----- #

# Declare variables
my %file_out_names;
my %file_out_handlers;
my %format_arrays;

# Prepare header for the formats output files
unshift @samples, 'variant_ID';

# For each format from header
foreach(@header_formats)
{
  # Make objects for each format
  my $cur_file_name = "$folder_out/${dataset}_$_.txt";
  my $cur_file_handler;
  my @format_array;
  
  # Make the output file and open it for writing
  open $cur_file_handler, ">$cur_file_name" or die "\nOutput file $cur_file_name cannot be created: $!\n\n";
  
  # Save handlers in hashes to access the files and arrays later
  $file_out_names{$_} = $cur_file_name;
  $file_out_handlers{$_} = $cur_file_handler;
  $format_arrays{$_} = \@format_array; # Note referencing!
  
  # Add header to the output file
  print {$file_out_handlers{$_}} join("\t", @samples)."\n"; # Note additional {} in sintax!

}

# ----- Progress report ----- #
print	"Made output files\n\n".
      "Analysing variants:\n\n";

# -------------------------------------------------------- #
#                Parse the variants records                #
# -------------------------------------------------------- #

# Declare variables
my $id_num = 0;
my $id;

my @cur_fields;

my $cur_fields_num;
my @vcf_data;

my $raw_info_data;
my @raw_info_data;

my @raw_info_elements;
my $raw_info_elements_num;

my %info_data;
my @info_data;
my $info_value;

my $raw_vep_data;
my @raw_vep_data;
my $vep_fields_num;
my @vep_data;

my @samples_data;

my $header_format;

my $line_formats;
my @line_formats;

my $line_format_no;
my $line_format;

my $sample_no;
my $sample_data;
my @sample_data;

# Remove field for id
shift @info_fields;

# Initial progress report
my $start_variant = sprintf("v%010d", $id_num + 1);
print "$start_variant\n";

# For each variant 
# (the input file is open, and we are already at the last line of header)
while (<$vcf_in_fh>) {

  # Increment counter
  $id_num++;
  $id = sprintf("v%010d", $id_num);
  
  # Progress report
  if ( $id_num % 100000 == 0 ) { 
    print "$id\n";
  }

  # Read line
  chomp; 
  @cur_fields = split /\t/;
  $cur_fields_num = scalar @cur_fields;

  # Check the num of fields
  if ( $cur_fields_num != $fields_num ){
    print "\nUnexpected number of fields ($id)\n\n";
    exit 1;
  }

  # --- vcf data --- #
  
  @vcf_data = @cur_fields[0..6]; # get data to array
  unshift @vcf_data, $id; # add variant id
  print $vcf_out_fh join("\t", @vcf_data)."\n"; # print to output file

  # --- info data --- #
  
  # Convert raw data to hash
  
  $raw_info_data = $cur_fields[7]; # get raw info data to scalar
  @raw_info_data = split /;/, $raw_info_data; # get array of raw info elements
  
  # Add element to hash if if the element is written as ID=VALUE
  foreach(@raw_info_data)
  {
    @raw_info_elements = split /=/;
    $raw_info_elements_num = scalar @raw_info_elements;
    if ( $raw_info_elements_num == 2 ) {
      $info_data{ $raw_info_elements[0] } = $raw_info_elements[1]; 
    } 
  }
  
  # Empty output array left after previous iteration 
  @info_data = ();
  
  # Prepare output array
  foreach(@info_fields)
  {
    if ( $_ ne "CSQ" ){ # omit vep data
    
      # Check that info field is present
      if (defined $info_data{$_}){
        $info_value = $info_data{$_}; # value for present info fields
      }else{
        $info_value = "NA"; # NA for absent info fields
      }
      push @info_data, $info_value; # add value to the array 
    }
  } # next info field

  unshift @info_data, $id; # add variant id
  print $info_out_fh join("\t", @info_data)."\n"; # print to output file
  
  # ----- vep data ----- #

  $raw_vep_data = $info_data{CSQ};
  @raw_vep_data = split /\|/, $raw_vep_data;
  
  # Some records contain less data, then the others, e.g. intergenic variants 
  # do not contain the field for the source of gene name ...
  
  $vep_fields_num = scalar @vep_fields;
  $vep_fields_num = $vep_fields_num - 1; # shorter for the ID field  
  
  @vep_data = ("") x $vep_fields_num; # Empty field is used for missed data
  
  for(0..$#raw_vep_data)
  {
    $vep_data[$_] = $raw_vep_data[$_];
  }
  
  unshift @vep_data, $id; # add variant id
  print $vep_out_fh join("\t", @vep_data)."\n"; # print to output file
  # Empty field is used for missed data
  
  # ----- samples data ----- #

  # Declare variables
  @samples_data = @cur_fields[9..$#cur_fields];
  $samples_num = scalar @samples_data;
  
  # Get line formats
  $line_formats = $cur_fields[8];
  @line_formats = split /:/, $line_formats;
  
  # Initialise arrays with "." for each format 
  # (consistent with vep's designation of missed data)
  foreach(@header_formats)
  {
    @{$format_arrays{$_}} = (".") x $samples_num; # Note additional {} in sintax!
  }

  # For each format in the file header
  foreach(@header_formats){
    $header_format = $_;
    
    # For each format in the line
    for(0..$#line_formats){
    
      # Get format number and value
      $line_format_no = $_;
      $line_format = $line_formats[$line_format_no];
      
      # If the format is present in the line
      if ($header_format eq $line_format){
        
        # For each sample
        for(0..$#samples_data){
        
          # Get sample number and string with data
          $sample_no = $_;
          $sample_data = $samples_data[$sample_no];
          
          # Read sample data to array
          @sample_data = split /:/, $sample_data;
          
          # Check that the format is present in sample data
          if (defined $sample_data[$line_format_no]){
            
            # Write data value to correspondet position of corresponded array
            @{$format_arrays{$header_format}}[$sample_no] = $sample_data[$line_format_no]; # Note additional {} in sintax!
          }
           
        } # next sample
      }
    } # next format in line
  } # next format in header
  
  # Save arrays to files
  foreach(@header_formats)
  {
    unshift @{$format_arrays{$_}}, $id; # add variant id
    print {$file_out_handlers{$_}} join("\t", @{$format_arrays{$_}})."\n"; # print to output file, note additional {} in sintax!
  }
  
} # next variant in the input file

# Close input file
close $vcf_in_fh or die "\nCannot close $vcf_in: $!\n\n"; 

# Close output files
close $vcf_out_fh or die "\nCannot close $vcf_out: $!\n\n";
close $info_out_fh or die "\nCannot close $info_out: $!\n\n";
close $vep_out_fh or die "\nCannot close $vep_out: $!\n\n";

foreach(@header_formats)
{
  close $file_out_handlers{$_} or die "\nCannot close $file_out_names{$_}: $!\n\n";
}

# Completion message
my $last_variant = sprintf("v%010d", $id_num);
print "$last_variant\n";

($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime();
print "\nCompleted: $hour:$min:$sec\n\n"; 
